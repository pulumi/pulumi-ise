// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networkaccess

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-ise/sdk/go/ise/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource can manage a Network Access Time And Date Condition.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ise/sdk/go/ise/networkaccess"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := networkaccess.NewTimeAndDateCondition(ctx, "example", &networkaccess.TimeAndDateConditionArgs{
//				Name:        pulumi.String("Cond1"),
//				Description: pulumi.String("My description"),
//				IsNegate:    pulumi.Bool(false),
//				WeekDays: pulumi.StringArray{
//					pulumi.String("Monday"),
//				},
//				WeekDaysExceptions: pulumi.StringArray{
//					pulumi.String("Tuesday"),
//				},
//				StartDate:          pulumi.String("2022-05-06"),
//				EndDate:            pulumi.String("2022-05-10"),
//				ExceptionStartDate: pulumi.String("2022-06-06"),
//				ExceptionEndDate:   pulumi.String("2022-06-10"),
//				StartTime:          pulumi.String("08:00"),
//				EndTime:            pulumi.String("15:00"),
//				ExceptionStartTime: pulumi.String("20:00"),
//				ExceptionEndTime:   pulumi.String("22:00"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import ise:networkaccess/timeAndDateCondition:TimeAndDateCondition example "76d24097-41c4-4558-a4d0-a8c07ac08470"
// ```
type TimeAndDateCondition struct {
	pulumi.CustomResourceState

	// Condition description
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// End date
	EndDate pulumi.StringPtrOutput `pulumi:"endDate"`
	// End time
	EndTime pulumi.StringPtrOutput `pulumi:"endTime"`
	// Exception end date
	ExceptionEndDate pulumi.StringPtrOutput `pulumi:"exceptionEndDate"`
	// Exception end time
	ExceptionEndTime pulumi.StringPtrOutput `pulumi:"exceptionEndTime"`
	// Exception start date
	ExceptionStartDate pulumi.StringPtrOutput `pulumi:"exceptionStartDate"`
	// Exception start time
	ExceptionStartTime pulumi.StringPtrOutput `pulumi:"exceptionStartTime"`
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrOutput `pulumi:"isNegate"`
	// Condition name
	Name pulumi.StringOutput `pulumi:"name"`
	// Start date
	StartDate pulumi.StringPtrOutput `pulumi:"startDate"`
	// Start time
	StartTime pulumi.StringPtrOutput `pulumi:"startTime"`
	// Defines for which days this condition will be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`. Default - List of all week days.
	WeekDays pulumi.StringArrayOutput `pulumi:"weekDays"`
	// Defines for which days this condition will NOT be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeekDaysExceptions pulumi.StringArrayOutput `pulumi:"weekDaysExceptions"`
}

// NewTimeAndDateCondition registers a new resource with the given unique name, arguments, and options.
func NewTimeAndDateCondition(ctx *pulumi.Context,
	name string, args *TimeAndDateConditionArgs, opts ...pulumi.ResourceOption) (*TimeAndDateCondition, error) {
	if args == nil {
		args = &TimeAndDateConditionArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TimeAndDateCondition
	err := ctx.RegisterResource("ise:networkaccess/timeAndDateCondition:TimeAndDateCondition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTimeAndDateCondition gets an existing TimeAndDateCondition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTimeAndDateCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TimeAndDateConditionState, opts ...pulumi.ResourceOption) (*TimeAndDateCondition, error) {
	var resource TimeAndDateCondition
	err := ctx.ReadResource("ise:networkaccess/timeAndDateCondition:TimeAndDateCondition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TimeAndDateCondition resources.
type timeAndDateConditionState struct {
	// Condition description
	Description *string `pulumi:"description"`
	// End date
	EndDate *string `pulumi:"endDate"`
	// End time
	EndTime *string `pulumi:"endTime"`
	// Exception end date
	ExceptionEndDate *string `pulumi:"exceptionEndDate"`
	// Exception end time
	ExceptionEndTime *string `pulumi:"exceptionEndTime"`
	// Exception start date
	ExceptionStartDate *string `pulumi:"exceptionStartDate"`
	// Exception start time
	ExceptionStartTime *string `pulumi:"exceptionStartTime"`
	// Indicates whereas this condition is in negate mode
	IsNegate *bool `pulumi:"isNegate"`
	// Condition name
	Name *string `pulumi:"name"`
	// Start date
	StartDate *string `pulumi:"startDate"`
	// Start time
	StartTime *string `pulumi:"startTime"`
	// Defines for which days this condition will be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`. Default - List of all week days.
	WeekDays []string `pulumi:"weekDays"`
	// Defines for which days this condition will NOT be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeekDaysExceptions []string `pulumi:"weekDaysExceptions"`
}

type TimeAndDateConditionState struct {
	// Condition description
	Description pulumi.StringPtrInput
	// End date
	EndDate pulumi.StringPtrInput
	// End time
	EndTime pulumi.StringPtrInput
	// Exception end date
	ExceptionEndDate pulumi.StringPtrInput
	// Exception end time
	ExceptionEndTime pulumi.StringPtrInput
	// Exception start date
	ExceptionStartDate pulumi.StringPtrInput
	// Exception start time
	ExceptionStartTime pulumi.StringPtrInput
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrInput
	// Condition name
	Name pulumi.StringPtrInput
	// Start date
	StartDate pulumi.StringPtrInput
	// Start time
	StartTime pulumi.StringPtrInput
	// Defines for which days this condition will be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`. Default - List of all week days.
	WeekDays pulumi.StringArrayInput
	// Defines for which days this condition will NOT be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeekDaysExceptions pulumi.StringArrayInput
}

func (TimeAndDateConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*timeAndDateConditionState)(nil)).Elem()
}

type timeAndDateConditionArgs struct {
	// Condition description
	Description *string `pulumi:"description"`
	// End date
	EndDate *string `pulumi:"endDate"`
	// End time
	EndTime *string `pulumi:"endTime"`
	// Exception end date
	ExceptionEndDate *string `pulumi:"exceptionEndDate"`
	// Exception end time
	ExceptionEndTime *string `pulumi:"exceptionEndTime"`
	// Exception start date
	ExceptionStartDate *string `pulumi:"exceptionStartDate"`
	// Exception start time
	ExceptionStartTime *string `pulumi:"exceptionStartTime"`
	// Indicates whereas this condition is in negate mode
	IsNegate *bool `pulumi:"isNegate"`
	// Condition name
	Name *string `pulumi:"name"`
	// Start date
	StartDate *string `pulumi:"startDate"`
	// Start time
	StartTime *string `pulumi:"startTime"`
	// Defines for which days this condition will be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`. Default - List of all week days.
	WeekDays []string `pulumi:"weekDays"`
	// Defines for which days this condition will NOT be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeekDaysExceptions []string `pulumi:"weekDaysExceptions"`
}

// The set of arguments for constructing a TimeAndDateCondition resource.
type TimeAndDateConditionArgs struct {
	// Condition description
	Description pulumi.StringPtrInput
	// End date
	EndDate pulumi.StringPtrInput
	// End time
	EndTime pulumi.StringPtrInput
	// Exception end date
	ExceptionEndDate pulumi.StringPtrInput
	// Exception end time
	ExceptionEndTime pulumi.StringPtrInput
	// Exception start date
	ExceptionStartDate pulumi.StringPtrInput
	// Exception start time
	ExceptionStartTime pulumi.StringPtrInput
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrInput
	// Condition name
	Name pulumi.StringPtrInput
	// Start date
	StartDate pulumi.StringPtrInput
	// Start time
	StartTime pulumi.StringPtrInput
	// Defines for which days this condition will be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`. Default - List of all week days.
	WeekDays pulumi.StringArrayInput
	// Defines for which days this condition will NOT be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeekDaysExceptions pulumi.StringArrayInput
}

func (TimeAndDateConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*timeAndDateConditionArgs)(nil)).Elem()
}

type TimeAndDateConditionInput interface {
	pulumi.Input

	ToTimeAndDateConditionOutput() TimeAndDateConditionOutput
	ToTimeAndDateConditionOutputWithContext(ctx context.Context) TimeAndDateConditionOutput
}

func (*TimeAndDateCondition) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeAndDateCondition)(nil)).Elem()
}

func (i *TimeAndDateCondition) ToTimeAndDateConditionOutput() TimeAndDateConditionOutput {
	return i.ToTimeAndDateConditionOutputWithContext(context.Background())
}

func (i *TimeAndDateCondition) ToTimeAndDateConditionOutputWithContext(ctx context.Context) TimeAndDateConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeAndDateConditionOutput)
}

// TimeAndDateConditionArrayInput is an input type that accepts TimeAndDateConditionArray and TimeAndDateConditionArrayOutput values.
// You can construct a concrete instance of `TimeAndDateConditionArrayInput` via:
//
//	TimeAndDateConditionArray{ TimeAndDateConditionArgs{...} }
type TimeAndDateConditionArrayInput interface {
	pulumi.Input

	ToTimeAndDateConditionArrayOutput() TimeAndDateConditionArrayOutput
	ToTimeAndDateConditionArrayOutputWithContext(context.Context) TimeAndDateConditionArrayOutput
}

type TimeAndDateConditionArray []TimeAndDateConditionInput

func (TimeAndDateConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TimeAndDateCondition)(nil)).Elem()
}

func (i TimeAndDateConditionArray) ToTimeAndDateConditionArrayOutput() TimeAndDateConditionArrayOutput {
	return i.ToTimeAndDateConditionArrayOutputWithContext(context.Background())
}

func (i TimeAndDateConditionArray) ToTimeAndDateConditionArrayOutputWithContext(ctx context.Context) TimeAndDateConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeAndDateConditionArrayOutput)
}

// TimeAndDateConditionMapInput is an input type that accepts TimeAndDateConditionMap and TimeAndDateConditionMapOutput values.
// You can construct a concrete instance of `TimeAndDateConditionMapInput` via:
//
//	TimeAndDateConditionMap{ "key": TimeAndDateConditionArgs{...} }
type TimeAndDateConditionMapInput interface {
	pulumi.Input

	ToTimeAndDateConditionMapOutput() TimeAndDateConditionMapOutput
	ToTimeAndDateConditionMapOutputWithContext(context.Context) TimeAndDateConditionMapOutput
}

type TimeAndDateConditionMap map[string]TimeAndDateConditionInput

func (TimeAndDateConditionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TimeAndDateCondition)(nil)).Elem()
}

func (i TimeAndDateConditionMap) ToTimeAndDateConditionMapOutput() TimeAndDateConditionMapOutput {
	return i.ToTimeAndDateConditionMapOutputWithContext(context.Background())
}

func (i TimeAndDateConditionMap) ToTimeAndDateConditionMapOutputWithContext(ctx context.Context) TimeAndDateConditionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeAndDateConditionMapOutput)
}

type TimeAndDateConditionOutput struct{ *pulumi.OutputState }

func (TimeAndDateConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeAndDateCondition)(nil)).Elem()
}

func (o TimeAndDateConditionOutput) ToTimeAndDateConditionOutput() TimeAndDateConditionOutput {
	return o
}

func (o TimeAndDateConditionOutput) ToTimeAndDateConditionOutputWithContext(ctx context.Context) TimeAndDateConditionOutput {
	return o
}

// Condition description
func (o TimeAndDateConditionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// End date
func (o TimeAndDateConditionOutput) EndDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.EndDate }).(pulumi.StringPtrOutput)
}

// End time
func (o TimeAndDateConditionOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.EndTime }).(pulumi.StringPtrOutput)
}

// Exception end date
func (o TimeAndDateConditionOutput) ExceptionEndDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.ExceptionEndDate }).(pulumi.StringPtrOutput)
}

// Exception end time
func (o TimeAndDateConditionOutput) ExceptionEndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.ExceptionEndTime }).(pulumi.StringPtrOutput)
}

// Exception start date
func (o TimeAndDateConditionOutput) ExceptionStartDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.ExceptionStartDate }).(pulumi.StringPtrOutput)
}

// Exception start time
func (o TimeAndDateConditionOutput) ExceptionStartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.ExceptionStartTime }).(pulumi.StringPtrOutput)
}

// Indicates whereas this condition is in negate mode
func (o TimeAndDateConditionOutput) IsNegate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.BoolPtrOutput { return v.IsNegate }).(pulumi.BoolPtrOutput)
}

// Condition name
func (o TimeAndDateConditionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Start date
func (o TimeAndDateConditionOutput) StartDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.StartDate }).(pulumi.StringPtrOutput)
}

// Start time
func (o TimeAndDateConditionOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringPtrOutput { return v.StartTime }).(pulumi.StringPtrOutput)
}

// Defines for which days this condition will be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`. Default - List of all week days.
func (o TimeAndDateConditionOutput) WeekDays() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringArrayOutput { return v.WeekDays }).(pulumi.StringArrayOutput)
}

// Defines for which days this condition will NOT be matched. List of weekdays - `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
func (o TimeAndDateConditionOutput) WeekDaysExceptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TimeAndDateCondition) pulumi.StringArrayOutput { return v.WeekDaysExceptions }).(pulumi.StringArrayOutput)
}

type TimeAndDateConditionArrayOutput struct{ *pulumi.OutputState }

func (TimeAndDateConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TimeAndDateCondition)(nil)).Elem()
}

func (o TimeAndDateConditionArrayOutput) ToTimeAndDateConditionArrayOutput() TimeAndDateConditionArrayOutput {
	return o
}

func (o TimeAndDateConditionArrayOutput) ToTimeAndDateConditionArrayOutputWithContext(ctx context.Context) TimeAndDateConditionArrayOutput {
	return o
}

func (o TimeAndDateConditionArrayOutput) Index(i pulumi.IntInput) TimeAndDateConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TimeAndDateCondition {
		return vs[0].([]*TimeAndDateCondition)[vs[1].(int)]
	}).(TimeAndDateConditionOutput)
}

type TimeAndDateConditionMapOutput struct{ *pulumi.OutputState }

func (TimeAndDateConditionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TimeAndDateCondition)(nil)).Elem()
}

func (o TimeAndDateConditionMapOutput) ToTimeAndDateConditionMapOutput() TimeAndDateConditionMapOutput {
	return o
}

func (o TimeAndDateConditionMapOutput) ToTimeAndDateConditionMapOutputWithContext(ctx context.Context) TimeAndDateConditionMapOutput {
	return o
}

func (o TimeAndDateConditionMapOutput) MapIndex(k pulumi.StringInput) TimeAndDateConditionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TimeAndDateCondition {
		return vs[0].(map[string]*TimeAndDateCondition)[vs[1].(string)]
	}).(TimeAndDateConditionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TimeAndDateConditionInput)(nil)).Elem(), &TimeAndDateCondition{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeAndDateConditionArrayInput)(nil)).Elem(), TimeAndDateConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeAndDateConditionMapInput)(nil)).Elem(), TimeAndDateConditionMap{})
	pulumi.RegisterOutputType(TimeAndDateConditionOutput{})
	pulumi.RegisterOutputType(TimeAndDateConditionArrayOutput{})
	pulumi.RegisterOutputType(TimeAndDateConditionMapOutput{})
}
