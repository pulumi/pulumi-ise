// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networkaccess

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-ise/sdk/go/ise/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource can manage a Network Access Condition.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ise/sdk/go/ise/networkaccess"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := networkaccess.NewCondition(ctx, "example", &networkaccess.ConditionArgs{
//				Name:           pulumi.String("Cond1"),
//				Description:    pulumi.String("My description"),
//				ConditionType:  pulumi.String("LibraryConditionAttributes"),
//				IsNegate:       pulumi.Bool(false),
//				AttributeName:  pulumi.String("EapAuthentication"),
//				AttributeValue: pulumi.String("EAP-TLS"),
//				DictionaryName: pulumi.String("Network Access"),
//				Operator:       pulumi.String("equals"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// ```sh
// $ pulumi import ise:networkaccess/condition:Condition example "76d24097-41c4-4558-a4d0-a8c07ac08470"
// ```
type Condition struct {
	pulumi.CustomResourceState

	// Dictionary attribute name
	AttributeName pulumi.StringPtrOutput `pulumi:"attributeName"`
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue pulumi.StringPtrOutput `pulumi:"attributeValue"`
	// List of child conditions. `conditionType` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens ConditionChildrenArrayOutput `pulumi:"childrens"`
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType pulumi.StringOutput `pulumi:"conditionType"`
	// Condition description
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Dictionary name
	DictionaryName pulumi.StringPtrOutput `pulumi:"dictionaryName"`
	// Dictionary value
	DictionaryValue pulumi.StringPtrOutput `pulumi:"dictionaryValue"`
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrOutput `pulumi:"isNegate"`
	// Condition name
	Name pulumi.StringOutput `pulumi:"name"`
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator pulumi.StringPtrOutput `pulumi:"operator"`
}

// NewCondition registers a new resource with the given unique name, arguments, and options.
func NewCondition(ctx *pulumi.Context,
	name string, args *ConditionArgs, opts ...pulumi.ResourceOption) (*Condition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConditionType == nil {
		return nil, errors.New("invalid value for required argument 'ConditionType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Condition
	err := ctx.RegisterResource("ise:networkaccess/condition:Condition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCondition gets an existing Condition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConditionState, opts ...pulumi.ResourceOption) (*Condition, error) {
	var resource Condition
	err := ctx.ReadResource("ise:networkaccess/condition:Condition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Condition resources.
type conditionState struct {
	// Dictionary attribute name
	AttributeName *string `pulumi:"attributeName"`
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue *string `pulumi:"attributeValue"`
	// List of child conditions. `conditionType` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens []ConditionChildren `pulumi:"childrens"`
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType *string `pulumi:"conditionType"`
	// Condition description
	Description *string `pulumi:"description"`
	// Dictionary name
	DictionaryName *string `pulumi:"dictionaryName"`
	// Dictionary value
	DictionaryValue *string `pulumi:"dictionaryValue"`
	// Indicates whereas this condition is in negate mode
	IsNegate *bool `pulumi:"isNegate"`
	// Condition name
	Name *string `pulumi:"name"`
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator *string `pulumi:"operator"`
}

type ConditionState struct {
	// Dictionary attribute name
	AttributeName pulumi.StringPtrInput
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue pulumi.StringPtrInput
	// List of child conditions. `conditionType` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens ConditionChildrenArrayInput
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType pulumi.StringPtrInput
	// Condition description
	Description pulumi.StringPtrInput
	// Dictionary name
	DictionaryName pulumi.StringPtrInput
	// Dictionary value
	DictionaryValue pulumi.StringPtrInput
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrInput
	// Condition name
	Name pulumi.StringPtrInput
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator pulumi.StringPtrInput
}

func (ConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*conditionState)(nil)).Elem()
}

type conditionArgs struct {
	// Dictionary attribute name
	AttributeName *string `pulumi:"attributeName"`
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue *string `pulumi:"attributeValue"`
	// List of child conditions. `conditionType` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens []ConditionChildren `pulumi:"childrens"`
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType string `pulumi:"conditionType"`
	// Condition description
	Description *string `pulumi:"description"`
	// Dictionary name
	DictionaryName *string `pulumi:"dictionaryName"`
	// Dictionary value
	DictionaryValue *string `pulumi:"dictionaryValue"`
	// Indicates whereas this condition is in negate mode
	IsNegate *bool `pulumi:"isNegate"`
	// Condition name
	Name *string `pulumi:"name"`
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator *string `pulumi:"operator"`
}

// The set of arguments for constructing a Condition resource.
type ConditionArgs struct {
	// Dictionary attribute name
	AttributeName pulumi.StringPtrInput
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue pulumi.StringPtrInput
	// List of child conditions. `conditionType` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens ConditionChildrenArrayInput
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType pulumi.StringInput
	// Condition description
	Description pulumi.StringPtrInput
	// Dictionary name
	DictionaryName pulumi.StringPtrInput
	// Dictionary value
	DictionaryValue pulumi.StringPtrInput
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrInput
	// Condition name
	Name pulumi.StringPtrInput
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator pulumi.StringPtrInput
}

func (ConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*conditionArgs)(nil)).Elem()
}

type ConditionInput interface {
	pulumi.Input

	ToConditionOutput() ConditionOutput
	ToConditionOutputWithContext(ctx context.Context) ConditionOutput
}

func (*Condition) ElementType() reflect.Type {
	return reflect.TypeOf((**Condition)(nil)).Elem()
}

func (i *Condition) ToConditionOutput() ConditionOutput {
	return i.ToConditionOutputWithContext(context.Background())
}

func (i *Condition) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionOutput)
}

// ConditionArrayInput is an input type that accepts ConditionArray and ConditionArrayOutput values.
// You can construct a concrete instance of `ConditionArrayInput` via:
//
//	ConditionArray{ ConditionArgs{...} }
type ConditionArrayInput interface {
	pulumi.Input

	ToConditionArrayOutput() ConditionArrayOutput
	ToConditionArrayOutputWithContext(context.Context) ConditionArrayOutput
}

type ConditionArray []ConditionInput

func (ConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Condition)(nil)).Elem()
}

func (i ConditionArray) ToConditionArrayOutput() ConditionArrayOutput {
	return i.ToConditionArrayOutputWithContext(context.Background())
}

func (i ConditionArray) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionArrayOutput)
}

// ConditionMapInput is an input type that accepts ConditionMap and ConditionMapOutput values.
// You can construct a concrete instance of `ConditionMapInput` via:
//
//	ConditionMap{ "key": ConditionArgs{...} }
type ConditionMapInput interface {
	pulumi.Input

	ToConditionMapOutput() ConditionMapOutput
	ToConditionMapOutputWithContext(context.Context) ConditionMapOutput
}

type ConditionMap map[string]ConditionInput

func (ConditionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Condition)(nil)).Elem()
}

func (i ConditionMap) ToConditionMapOutput() ConditionMapOutput {
	return i.ToConditionMapOutputWithContext(context.Background())
}

func (i ConditionMap) ToConditionMapOutputWithContext(ctx context.Context) ConditionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionMapOutput)
}

type ConditionOutput struct{ *pulumi.OutputState }

func (ConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Condition)(nil)).Elem()
}

func (o ConditionOutput) ToConditionOutput() ConditionOutput {
	return o
}

func (o ConditionOutput) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return o
}

// Dictionary attribute name
func (o ConditionOutput) AttributeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringPtrOutput { return v.AttributeName }).(pulumi.StringPtrOutput)
}

// Attribute value for condition. Value type is specified in dictionary object.
func (o ConditionOutput) AttributeValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringPtrOutput { return v.AttributeValue }).(pulumi.StringPtrOutput)
}

// List of child conditions. `conditionType` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
func (o ConditionOutput) Childrens() ConditionChildrenArrayOutput {
	return o.ApplyT(func(v *Condition) ConditionChildrenArrayOutput { return v.Childrens }).(ConditionChildrenArrayOutput)
}

// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
func (o ConditionOutput) ConditionType() pulumi.StringOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringOutput { return v.ConditionType }).(pulumi.StringOutput)
}

// Condition description
func (o ConditionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Dictionary name
func (o ConditionOutput) DictionaryName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringPtrOutput { return v.DictionaryName }).(pulumi.StringPtrOutput)
}

// Dictionary value
func (o ConditionOutput) DictionaryValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringPtrOutput { return v.DictionaryValue }).(pulumi.StringPtrOutput)
}

// Indicates whereas this condition is in negate mode
func (o ConditionOutput) IsNegate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Condition) pulumi.BoolPtrOutput { return v.IsNegate }).(pulumi.BoolPtrOutput)
}

// Condition name
func (o ConditionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
func (o ConditionOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Condition) pulumi.StringPtrOutput { return v.Operator }).(pulumi.StringPtrOutput)
}

type ConditionArrayOutput struct{ *pulumi.OutputState }

func (ConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Condition)(nil)).Elem()
}

func (o ConditionArrayOutput) ToConditionArrayOutput() ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) Index(i pulumi.IntInput) ConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Condition {
		return vs[0].([]*Condition)[vs[1].(int)]
	}).(ConditionOutput)
}

type ConditionMapOutput struct{ *pulumi.OutputState }

func (ConditionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Condition)(nil)).Elem()
}

func (o ConditionMapOutput) ToConditionMapOutput() ConditionMapOutput {
	return o
}

func (o ConditionMapOutput) ToConditionMapOutputWithContext(ctx context.Context) ConditionMapOutput {
	return o
}

func (o ConditionMapOutput) MapIndex(k pulumi.StringInput) ConditionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Condition {
		return vs[0].(map[string]*Condition)[vs[1].(string)]
	}).(ConditionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionInput)(nil)).Elem(), &Condition{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionArrayInput)(nil)).Elem(), ConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionMapInput)(nil)).Elem(), ConditionMap{})
	pulumi.RegisterOutputType(ConditionOutput{})
	pulumi.RegisterOutputType(ConditionArrayOutput{})
	pulumi.RegisterOutputType(ConditionMapOutput{})
}
