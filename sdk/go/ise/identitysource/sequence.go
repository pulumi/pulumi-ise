// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package identitysource

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-ise/sdk/go/ise/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource can manage an Identity Source Sequence.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ise/sdk/go/ise/IdentitySource"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := IdentitySource.NewSequence(ctx, "example", &IdentitySource.SequenceArgs{
//				Name:                             pulumi.String("Sequence1"),
//				Description:                      pulumi.String("My identity source sequence"),
//				BreakOnStoreFail:                 pulumi.Bool(true),
//				CertificateAuthenticationProfile: pulumi.String("Preloaded_Certificate_Profile"),
//				IdentitySources: identitysource.SequenceIdentitySourceArray{
//					&identitysource.SequenceIdentitySourceArgs{
//						Name:  pulumi.String("Internal Users"),
//						Order: pulumi.Int(1),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import ise:IdentitySource/sequence:Sequence example "76d24097-41c4-4558-a4d0-a8c07ac08470"
// ```
type Sequence struct {
	pulumi.CustomResourceState

	// Do not access other stores in the sequence if a selected identity store cannot be accessed for authentication
	BreakOnStoreFail pulumi.BoolOutput `pulumi:"breakOnStoreFail"`
	// Certificate Authentication Profile, empty if doesn't exist
	CertificateAuthenticationProfile pulumi.StringOutput `pulumi:"certificateAuthenticationProfile"`
	// Description
	Description     pulumi.StringPtrOutput            `pulumi:"description"`
	IdentitySources SequenceIdentitySourceArrayOutput `pulumi:"identitySources"`
	// The name of the identity source sequence
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewSequence registers a new resource with the given unique name, arguments, and options.
func NewSequence(ctx *pulumi.Context,
	name string, args *SequenceArgs, opts ...pulumi.ResourceOption) (*Sequence, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.BreakOnStoreFail == nil {
		return nil, errors.New("invalid value for required argument 'BreakOnStoreFail'")
	}
	if args.CertificateAuthenticationProfile == nil {
		return nil, errors.New("invalid value for required argument 'CertificateAuthenticationProfile'")
	}
	if args.IdentitySources == nil {
		return nil, errors.New("invalid value for required argument 'IdentitySources'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Sequence
	err := ctx.RegisterResource("ise:IdentitySource/sequence:Sequence", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSequence gets an existing Sequence resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSequence(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SequenceState, opts ...pulumi.ResourceOption) (*Sequence, error) {
	var resource Sequence
	err := ctx.ReadResource("ise:IdentitySource/sequence:Sequence", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Sequence resources.
type sequenceState struct {
	// Do not access other stores in the sequence if a selected identity store cannot be accessed for authentication
	BreakOnStoreFail *bool `pulumi:"breakOnStoreFail"`
	// Certificate Authentication Profile, empty if doesn't exist
	CertificateAuthenticationProfile *string `pulumi:"certificateAuthenticationProfile"`
	// Description
	Description     *string                  `pulumi:"description"`
	IdentitySources []SequenceIdentitySource `pulumi:"identitySources"`
	// The name of the identity source sequence
	Name *string `pulumi:"name"`
}

type SequenceState struct {
	// Do not access other stores in the sequence if a selected identity store cannot be accessed for authentication
	BreakOnStoreFail pulumi.BoolPtrInput
	// Certificate Authentication Profile, empty if doesn't exist
	CertificateAuthenticationProfile pulumi.StringPtrInput
	// Description
	Description     pulumi.StringPtrInput
	IdentitySources SequenceIdentitySourceArrayInput
	// The name of the identity source sequence
	Name pulumi.StringPtrInput
}

func (SequenceState) ElementType() reflect.Type {
	return reflect.TypeOf((*sequenceState)(nil)).Elem()
}

type sequenceArgs struct {
	// Do not access other stores in the sequence if a selected identity store cannot be accessed for authentication
	BreakOnStoreFail bool `pulumi:"breakOnStoreFail"`
	// Certificate Authentication Profile, empty if doesn't exist
	CertificateAuthenticationProfile string `pulumi:"certificateAuthenticationProfile"`
	// Description
	Description     *string                  `pulumi:"description"`
	IdentitySources []SequenceIdentitySource `pulumi:"identitySources"`
	// The name of the identity source sequence
	Name *string `pulumi:"name"`
}

// The set of arguments for constructing a Sequence resource.
type SequenceArgs struct {
	// Do not access other stores in the sequence if a selected identity store cannot be accessed for authentication
	BreakOnStoreFail pulumi.BoolInput
	// Certificate Authentication Profile, empty if doesn't exist
	CertificateAuthenticationProfile pulumi.StringInput
	// Description
	Description     pulumi.StringPtrInput
	IdentitySources SequenceIdentitySourceArrayInput
	// The name of the identity source sequence
	Name pulumi.StringPtrInput
}

func (SequenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sequenceArgs)(nil)).Elem()
}

type SequenceInput interface {
	pulumi.Input

	ToSequenceOutput() SequenceOutput
	ToSequenceOutputWithContext(ctx context.Context) SequenceOutput
}

func (*Sequence) ElementType() reflect.Type {
	return reflect.TypeOf((**Sequence)(nil)).Elem()
}

func (i *Sequence) ToSequenceOutput() SequenceOutput {
	return i.ToSequenceOutputWithContext(context.Background())
}

func (i *Sequence) ToSequenceOutputWithContext(ctx context.Context) SequenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SequenceOutput)
}

// SequenceArrayInput is an input type that accepts SequenceArray and SequenceArrayOutput values.
// You can construct a concrete instance of `SequenceArrayInput` via:
//
//	SequenceArray{ SequenceArgs{...} }
type SequenceArrayInput interface {
	pulumi.Input

	ToSequenceArrayOutput() SequenceArrayOutput
	ToSequenceArrayOutputWithContext(context.Context) SequenceArrayOutput
}

type SequenceArray []SequenceInput

func (SequenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sequence)(nil)).Elem()
}

func (i SequenceArray) ToSequenceArrayOutput() SequenceArrayOutput {
	return i.ToSequenceArrayOutputWithContext(context.Background())
}

func (i SequenceArray) ToSequenceArrayOutputWithContext(ctx context.Context) SequenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SequenceArrayOutput)
}

// SequenceMapInput is an input type that accepts SequenceMap and SequenceMapOutput values.
// You can construct a concrete instance of `SequenceMapInput` via:
//
//	SequenceMap{ "key": SequenceArgs{...} }
type SequenceMapInput interface {
	pulumi.Input

	ToSequenceMapOutput() SequenceMapOutput
	ToSequenceMapOutputWithContext(context.Context) SequenceMapOutput
}

type SequenceMap map[string]SequenceInput

func (SequenceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sequence)(nil)).Elem()
}

func (i SequenceMap) ToSequenceMapOutput() SequenceMapOutput {
	return i.ToSequenceMapOutputWithContext(context.Background())
}

func (i SequenceMap) ToSequenceMapOutputWithContext(ctx context.Context) SequenceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SequenceMapOutput)
}

type SequenceOutput struct{ *pulumi.OutputState }

func (SequenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Sequence)(nil)).Elem()
}

func (o SequenceOutput) ToSequenceOutput() SequenceOutput {
	return o
}

func (o SequenceOutput) ToSequenceOutputWithContext(ctx context.Context) SequenceOutput {
	return o
}

// Do not access other stores in the sequence if a selected identity store cannot be accessed for authentication
func (o SequenceOutput) BreakOnStoreFail() pulumi.BoolOutput {
	return o.ApplyT(func(v *Sequence) pulumi.BoolOutput { return v.BreakOnStoreFail }).(pulumi.BoolOutput)
}

// Certificate Authentication Profile, empty if doesn't exist
func (o SequenceOutput) CertificateAuthenticationProfile() pulumi.StringOutput {
	return o.ApplyT(func(v *Sequence) pulumi.StringOutput { return v.CertificateAuthenticationProfile }).(pulumi.StringOutput)
}

// Description
func (o SequenceOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sequence) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o SequenceOutput) IdentitySources() SequenceIdentitySourceArrayOutput {
	return o.ApplyT(func(v *Sequence) SequenceIdentitySourceArrayOutput { return v.IdentitySources }).(SequenceIdentitySourceArrayOutput)
}

// The name of the identity source sequence
func (o SequenceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Sequence) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type SequenceArrayOutput struct{ *pulumi.OutputState }

func (SequenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sequence)(nil)).Elem()
}

func (o SequenceArrayOutput) ToSequenceArrayOutput() SequenceArrayOutput {
	return o
}

func (o SequenceArrayOutput) ToSequenceArrayOutputWithContext(ctx context.Context) SequenceArrayOutput {
	return o
}

func (o SequenceArrayOutput) Index(i pulumi.IntInput) SequenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Sequence {
		return vs[0].([]*Sequence)[vs[1].(int)]
	}).(SequenceOutput)
}

type SequenceMapOutput struct{ *pulumi.OutputState }

func (SequenceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sequence)(nil)).Elem()
}

func (o SequenceMapOutput) ToSequenceMapOutput() SequenceMapOutput {
	return o
}

func (o SequenceMapOutput) ToSequenceMapOutputWithContext(ctx context.Context) SequenceMapOutput {
	return o
}

func (o SequenceMapOutput) MapIndex(k pulumi.StringInput) SequenceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Sequence {
		return vs[0].(map[string]*Sequence)[vs[1].(string)]
	}).(SequenceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SequenceInput)(nil)).Elem(), &Sequence{})
	pulumi.RegisterInputType(reflect.TypeOf((*SequenceArrayInput)(nil)).Elem(), SequenceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SequenceMapInput)(nil)).Elem(), SequenceMap{})
	pulumi.RegisterOutputType(SequenceOutput{})
	pulumi.RegisterOutputType(SequenceArrayOutput{})
	pulumi.RegisterOutputType(SequenceMapOutput{})
}
