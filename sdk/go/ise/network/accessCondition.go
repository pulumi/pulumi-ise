// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package network

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-ise/sdk/go/ise/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource can manage a Network Access Condition.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ise/sdk/go/ise/network"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := network.NewAccessCondition(ctx, "example", &network.AccessConditionArgs{
//				Name:           pulumi.String("Cond1"),
//				Description:    pulumi.String("My description"),
//				ConditionType:  pulumi.String("LibraryConditionAttributes"),
//				IsNegate:       pulumi.Bool(false),
//				AttributeName:  pulumi.String("EapAuthentication"),
//				AttributeValue: pulumi.String("EAP-TLS"),
//				DictionaryName: pulumi.String("Network Access"),
//				Operator:       pulumi.String("equals"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import ise:network/accessCondition:AccessCondition example "76d24097-41c4-4558-a4d0-a8c07ac08470"
// ```
type AccessCondition struct {
	pulumi.CustomResourceState

	// Dictionary attribute name
	AttributeName pulumi.StringPtrOutput `pulumi:"attributeName"`
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue pulumi.StringPtrOutput `pulumi:"attributeValue"`
	// List of child conditions. `condition_type` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens AccessConditionChildrenArrayOutput `pulumi:"childrens"`
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType pulumi.StringOutput `pulumi:"conditionType"`
	// Condition description
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Dictionary name
	DictionaryName pulumi.StringPtrOutput `pulumi:"dictionaryName"`
	// Dictionary value
	DictionaryValue pulumi.StringPtrOutput `pulumi:"dictionaryValue"`
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrOutput `pulumi:"isNegate"`
	// Condition name
	Name pulumi.StringOutput `pulumi:"name"`
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator pulumi.StringPtrOutput `pulumi:"operator"`
}

// NewAccessCondition registers a new resource with the given unique name, arguments, and options.
func NewAccessCondition(ctx *pulumi.Context,
	name string, args *AccessConditionArgs, opts ...pulumi.ResourceOption) (*AccessCondition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConditionType == nil {
		return nil, errors.New("invalid value for required argument 'ConditionType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AccessCondition
	err := ctx.RegisterResource("ise:network/accessCondition:AccessCondition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAccessCondition gets an existing AccessCondition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccessCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AccessConditionState, opts ...pulumi.ResourceOption) (*AccessCondition, error) {
	var resource AccessCondition
	err := ctx.ReadResource("ise:network/accessCondition:AccessCondition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AccessCondition resources.
type accessConditionState struct {
	// Dictionary attribute name
	AttributeName *string `pulumi:"attributeName"`
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue *string `pulumi:"attributeValue"`
	// List of child conditions. `condition_type` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens []AccessConditionChildren `pulumi:"childrens"`
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType *string `pulumi:"conditionType"`
	// Condition description
	Description *string `pulumi:"description"`
	// Dictionary name
	DictionaryName *string `pulumi:"dictionaryName"`
	// Dictionary value
	DictionaryValue *string `pulumi:"dictionaryValue"`
	// Indicates whereas this condition is in negate mode
	IsNegate *bool `pulumi:"isNegate"`
	// Condition name
	Name *string `pulumi:"name"`
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator *string `pulumi:"operator"`
}

type AccessConditionState struct {
	// Dictionary attribute name
	AttributeName pulumi.StringPtrInput
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue pulumi.StringPtrInput
	// List of child conditions. `condition_type` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens AccessConditionChildrenArrayInput
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType pulumi.StringPtrInput
	// Condition description
	Description pulumi.StringPtrInput
	// Dictionary name
	DictionaryName pulumi.StringPtrInput
	// Dictionary value
	DictionaryValue pulumi.StringPtrInput
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrInput
	// Condition name
	Name pulumi.StringPtrInput
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator pulumi.StringPtrInput
}

func (AccessConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*accessConditionState)(nil)).Elem()
}

type accessConditionArgs struct {
	// Dictionary attribute name
	AttributeName *string `pulumi:"attributeName"`
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue *string `pulumi:"attributeValue"`
	// List of child conditions. `condition_type` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens []AccessConditionChildren `pulumi:"childrens"`
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType string `pulumi:"conditionType"`
	// Condition description
	Description *string `pulumi:"description"`
	// Dictionary name
	DictionaryName *string `pulumi:"dictionaryName"`
	// Dictionary value
	DictionaryValue *string `pulumi:"dictionaryValue"`
	// Indicates whereas this condition is in negate mode
	IsNegate *bool `pulumi:"isNegate"`
	// Condition name
	Name *string `pulumi:"name"`
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator *string `pulumi:"operator"`
}

// The set of arguments for constructing a AccessCondition resource.
type AccessConditionArgs struct {
	// Dictionary attribute name
	AttributeName pulumi.StringPtrInput
	// Attribute value for condition. Value type is specified in dictionary object.
	AttributeValue pulumi.StringPtrInput
	// List of child conditions. `condition_type` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
	Childrens AccessConditionChildrenArrayInput
	// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
	// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
	// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
	ConditionType pulumi.StringInput
	// Condition description
	Description pulumi.StringPtrInput
	// Dictionary name
	DictionaryName pulumi.StringPtrInput
	// Dictionary value
	DictionaryValue pulumi.StringPtrInput
	// Indicates whereas this condition is in negate mode
	IsNegate pulumi.BoolPtrInput
	// Condition name
	Name pulumi.StringPtrInput
	// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
	// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
	// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
	Operator pulumi.StringPtrInput
}

func (AccessConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*accessConditionArgs)(nil)).Elem()
}

type AccessConditionInput interface {
	pulumi.Input

	ToAccessConditionOutput() AccessConditionOutput
	ToAccessConditionOutputWithContext(ctx context.Context) AccessConditionOutput
}

func (*AccessCondition) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessCondition)(nil)).Elem()
}

func (i *AccessCondition) ToAccessConditionOutput() AccessConditionOutput {
	return i.ToAccessConditionOutputWithContext(context.Background())
}

func (i *AccessCondition) ToAccessConditionOutputWithContext(ctx context.Context) AccessConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessConditionOutput)
}

// AccessConditionArrayInput is an input type that accepts AccessConditionArray and AccessConditionArrayOutput values.
// You can construct a concrete instance of `AccessConditionArrayInput` via:
//
//	AccessConditionArray{ AccessConditionArgs{...} }
type AccessConditionArrayInput interface {
	pulumi.Input

	ToAccessConditionArrayOutput() AccessConditionArrayOutput
	ToAccessConditionArrayOutputWithContext(context.Context) AccessConditionArrayOutput
}

type AccessConditionArray []AccessConditionInput

func (AccessConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccessCondition)(nil)).Elem()
}

func (i AccessConditionArray) ToAccessConditionArrayOutput() AccessConditionArrayOutput {
	return i.ToAccessConditionArrayOutputWithContext(context.Background())
}

func (i AccessConditionArray) ToAccessConditionArrayOutputWithContext(ctx context.Context) AccessConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessConditionArrayOutput)
}

// AccessConditionMapInput is an input type that accepts AccessConditionMap and AccessConditionMapOutput values.
// You can construct a concrete instance of `AccessConditionMapInput` via:
//
//	AccessConditionMap{ "key": AccessConditionArgs{...} }
type AccessConditionMapInput interface {
	pulumi.Input

	ToAccessConditionMapOutput() AccessConditionMapOutput
	ToAccessConditionMapOutputWithContext(context.Context) AccessConditionMapOutput
}

type AccessConditionMap map[string]AccessConditionInput

func (AccessConditionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccessCondition)(nil)).Elem()
}

func (i AccessConditionMap) ToAccessConditionMapOutput() AccessConditionMapOutput {
	return i.ToAccessConditionMapOutputWithContext(context.Background())
}

func (i AccessConditionMap) ToAccessConditionMapOutputWithContext(ctx context.Context) AccessConditionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessConditionMapOutput)
}

type AccessConditionOutput struct{ *pulumi.OutputState }

func (AccessConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessCondition)(nil)).Elem()
}

func (o AccessConditionOutput) ToAccessConditionOutput() AccessConditionOutput {
	return o
}

func (o AccessConditionOutput) ToAccessConditionOutputWithContext(ctx context.Context) AccessConditionOutput {
	return o
}

// Dictionary attribute name
func (o AccessConditionOutput) AttributeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringPtrOutput { return v.AttributeName }).(pulumi.StringPtrOutput)
}

// Attribute value for condition. Value type is specified in dictionary object.
func (o AccessConditionOutput) AttributeValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringPtrOutput { return v.AttributeValue }).(pulumi.StringPtrOutput)
}

// List of child conditions. `condition_type` must be one of `LibraryConditionAndBlock` or `LibraryConditionOrBlock`.
func (o AccessConditionOutput) Childrens() AccessConditionChildrenArrayOutput {
	return o.ApplyT(func(v *AccessCondition) AccessConditionChildrenArrayOutput { return v.Childrens }).(AccessConditionChildrenArrayOutput)
}

// Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that
// additional conditions are present under the children attribute. - Choices: `LibraryConditionAndBlock`,
// `LibraryConditionAttributes`, `LibraryConditionOrBlock`
func (o AccessConditionOutput) ConditionType() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringOutput { return v.ConditionType }).(pulumi.StringOutput)
}

// Condition description
func (o AccessConditionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Dictionary name
func (o AccessConditionOutput) DictionaryName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringPtrOutput { return v.DictionaryName }).(pulumi.StringPtrOutput)
}

// Dictionary value
func (o AccessConditionOutput) DictionaryValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringPtrOutput { return v.DictionaryValue }).(pulumi.StringPtrOutput)
}

// Indicates whereas this condition is in negate mode
func (o AccessConditionOutput) IsNegate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.BoolPtrOutput { return v.IsNegate }).(pulumi.BoolPtrOutput)
}

// Condition name
func (o AccessConditionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Equality operator - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`,
// `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`,
// `notEquals`, `notIn`, `notStartsWith`, `startsWith`
func (o AccessConditionOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessCondition) pulumi.StringPtrOutput { return v.Operator }).(pulumi.StringPtrOutput)
}

type AccessConditionArrayOutput struct{ *pulumi.OutputState }

func (AccessConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccessCondition)(nil)).Elem()
}

func (o AccessConditionArrayOutput) ToAccessConditionArrayOutput() AccessConditionArrayOutput {
	return o
}

func (o AccessConditionArrayOutput) ToAccessConditionArrayOutputWithContext(ctx context.Context) AccessConditionArrayOutput {
	return o
}

func (o AccessConditionArrayOutput) Index(i pulumi.IntInput) AccessConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AccessCondition {
		return vs[0].([]*AccessCondition)[vs[1].(int)]
	}).(AccessConditionOutput)
}

type AccessConditionMapOutput struct{ *pulumi.OutputState }

func (AccessConditionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccessCondition)(nil)).Elem()
}

func (o AccessConditionMapOutput) ToAccessConditionMapOutput() AccessConditionMapOutput {
	return o
}

func (o AccessConditionMapOutput) ToAccessConditionMapOutputWithContext(ctx context.Context) AccessConditionMapOutput {
	return o
}

func (o AccessConditionMapOutput) MapIndex(k pulumi.StringInput) AccessConditionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AccessCondition {
		return vs[0].(map[string]*AccessCondition)[vs[1].(string)]
	}).(AccessConditionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccessConditionInput)(nil)).Elem(), &AccessCondition{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessConditionArrayInput)(nil)).Elem(), AccessConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessConditionMapInput)(nil)).Elem(), AccessConditionMap{})
	pulumi.RegisterOutputType(AccessConditionOutput{})
	pulumi.RegisterOutputType(AccessConditionArrayOutput{})
	pulumi.RegisterOutputType(AccessConditionMapOutput{})
}
